<!DOCTYPE html>
<html>
<head>
    <title>A-Frame AR Magic Volume - Dynamic Silhouette</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vWorldPosition; 
        void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec3 uBaseColor;
        uniform float uWindowActive; 
        uniform mat4 uWindowInvMat; 
        uniform vec3 uBoxDim; 
        uniform vec3 uBoxScale; 
        uniform vec3 uCameraWorldPos; 

        varying vec3 vWorldPosition; 

        vec2 rayBoxIntersection(vec3 ro, vec3 rd, vec3 halfDim) {
            vec3 m = 1.0 / rd;
            vec3 n = m * ro;
            vec3 k = abs(m) * halfDim;
            vec3 t1 = -n - k;
            vec3 t2 = -n + k;
            float tNear = max(max(t1.x, t1.y), t1.z);
            float tFar = min(min(t2.x, t2.y), t2.z);
            return vec2(tNear, tFar);
        }

        void main() {
            vec3 finalColor = uBaseColor; 
            float alpha = 1.0;

            if (uWindowActive > 0.5) {
                vec3 worldDir = normalize(vWorldPosition - uCameraWorldPos);
                vec3 ro = (uWindowInvMat * vec4(uCameraWorldPos, 1.0)).xyz;
                vec3 rd = normalize((uWindowInvMat * vec4(worldDir, 0.0)).xyz);
                vec3 halfDim = (uBoxDim * uBoxScale) * 0.5;

                vec2 hit = rayBoxIntersection(ro, rd, halfDim);
                float tNear = hit.x;
                float tFar = hit.y;

                if (tNear < tFar && tFar > 0.0) {
                    float distToObj = distance(uCameraWorldPos, vWorldPosition);
                    if (distToObj < tFar) {
                        alpha = 0.2;
                    }
                }
            }
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const ELEMENT_SIZE = 0.1; 
        const WINDOW_BOX_SIZE = { w: 0.4, h: 0.3, d: 0.4 }; 

        let isMagicWindowVisible = false;
        let magicObjects = [];

        AFRAME.registerComponent('apply-magic-shader', {
            schema: { color: {type: 'color', default: '#FFFFFF'} },
            init: function() {
                magicObjects.push(this);
                this.cameraPos = new AFRAME.THREE.Vector3();
                this.material = new AFRAME.THREE.ShaderMaterial({
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                    uniforms: {
                        uBaseColor: { value: new AFRAME.THREE.Color(this.data.color) },
                        uWindowActive: { value: isMagicWindowVisible ? 1.0 : 0.0 },
                        uWindowInvMat: { value: new AFRAME.THREE.Matrix4() }, 
                        uBoxDim: { value: new AFRAME.THREE.Vector3(WINDOW_BOX_SIZE.w, WINDOW_BOX_SIZE.h, WINDOW_BOX_SIZE.d) },
                        uBoxScale: { value: new AFRAME.THREE.Vector3(1, 1, 1) },
                        uCameraWorldPos: { value: this.cameraPos }
                    },
                    transparent: true,
                    side: AFRAME.THREE.DoubleSide
                });

                const applyMat = () => {
                    const mesh = this.el.getObject3D('mesh');
                    if (mesh) mesh.material = this.material;
                };
                if (this.el.getObject3D('mesh')) applyMat();
                else this.el.addEventListener('model-loaded', applyMat);
            },
            tick: function() {
                const cam = this.el.sceneEl.camera;
                if (cam) { cam.getWorldPosition(this.cameraPos); }
            },
            remove: function() {
                const index = magicObjects.indexOf(this);
                if (index > -1) magicObjects.splice(index, 1);
            },
            setWindowActive: function(isActive) {
                if (this.material) this.material.uniforms.uWindowActive.value = isActive ? 1.0 : 0.0;
            },
            updateWindowParams: function(invMat, scale) {
                if (this.material) {
                    this.material.uniforms.uWindowInvMat.value.copy(invMat);
                    this.material.uniforms.uBoxScale.value.copy(scale);
                }
            }
        });

        AFRAME.registerComponent('dynamic-silhouette', {
            init: function() {
                this.cameraPos = new AFRAME.THREE.Vector3();
                this.boxCenter = new AFRAME.THREE.Vector3();
                this.viewDir = new AFRAME.THREE.Vector3();
                
                // 12条边
                this.edges = [
                    [0, 1], [1, 2], [2, 3], [3, 0], // 底面
                    [4, 5], [5, 6], [6, 7], [7, 4], // 顶面
                    [0, 4], [1, 5], [2, 6], [3, 7]  // 竖边
                ];
                
                // 面的局部法线
                this.faceNormals = [
                    new AFRAME.THREE.Vector3(0, -1, 0), // 0: 底面
                    new AFRAME.THREE.Vector3(0, 1, 0),  // 1: 顶面
                    new AFRAME.THREE.Vector3(0, 0, -1), // 2: 前面
                    new AFRAME.THREE.Vector3(0, 0, 1),  // 3: 后面
                    new AFRAME.THREE.Vector3(-1, 0, 0), // 4: 左面
                    new AFRAME.THREE.Vector3(1, 0, 0)   // 5: 右面
                ];
                
                // 每条边相邻的两个面索引
                this.edgeToFaces = [
                    [0, 2], [0, 5], [0, 3], [0, 4], // 底边 (与前后左右面相邻)
                    [1, 2], [1, 5], [1, 3], [1, 4], // 顶边 (与前后左右面相邻)
                    [2, 4], [2, 5], [3, 5], [3, 4]  // 竖边
                ];
            },
            
            tick: function() {
                const mesh = this.el.getObject3D('mesh');
                if (!mesh) return;
                const camera = this.el.sceneEl.camera;
                if (!camera) return;
                
                camera.getWorldPosition(this.cameraPos);
                this.el.object3D.getWorldPosition(this.boxCenter);
                // 视线向量：从物体指向相机
                this.viewDir.subVectors(this.cameraPos, this.boxCenter).normalize();
                
                const silhouetteEdges = [];
                const normalMatrix = new AFRAME.THREE.Matrix3().getNormalMatrix(this.el.object3D.matrixWorld);
                
                // 设定一个极小的阈值，处理正视时点积为 0 的情况
                const epsilon = 0.08; 

                for (let i = 0; i < this.edges.length; i++) {
                    const [f1, f2] = this.edgeToFaces[i];
                    
                    const n1 = this.faceNormals[f1].clone().applyMatrix3(normalMatrix).normalize();
                    const n2 = this.faceNormals[f2].clone().applyMatrix3(normalMatrix).normalize();
                    
                    const dot1 = n1.dot(this.viewDir);
                    const dot2 = n2.dot(this.viewDir);
                    
                    // 【核心判定逻辑】
                    // 如果一个面是明显的正面（> epsilon），而另一个面不是（<= epsilon）
                    // 那么这条边就是最外层的轮廓边
                    if ((dot1 > epsilon && dot2 <= epsilon) || (dot2 > epsilon && dot1 <= epsilon)) {
                        silhouetteEdges.push(this.edges[i]);
                    }
                }
                
                this.updateSilhouetteGeometry(silhouetteEdges);
            },
            
            updateSilhouetteGeometry: function(silhouetteEdges) {
                const mesh = this.el.getObject3D('mesh');
                if (!mesh) return;
                
                let silhouetteLine = mesh.getObjectByName('silhouetteLine');
                if (silhouetteLine) {
                    mesh.remove(silhouetteLine);
                    silhouetteLine.geometry.dispose();
                }
                
                if (silhouetteEdges.length > 0) {
                    const w = WINDOW_BOX_SIZE.w / 2;
                    const h = WINDOW_BOX_SIZE.h / 2;
                    const d = WINDOW_BOX_SIZE.d / 2;
                    
                    // 【修复后的顶点坐标】
                    const vertices = [
                        [-w, -h, -d], [w, -h, -d], [w, -h, d], [-w, -h, d], // 底面 0-3
                        [-w, h, -d],  [w, h, -d],  [w, h, d],  [-w, h, d]   // 顶面 4-7
                    ];
                    
                    const positions = [];
                    for (let edge of silhouetteEdges) {
                        const [v1, v2] = edge;
                        positions.push(...vertices[v1], ...vertices[v2]);
                    }
                    
                    const geometry = new AFRAME.THREE.BufferGeometry();
                    geometry.setAttribute('position', new AFRAME.THREE.Float32BufferAttribute(positions, 3));
                    
                    const material = new AFRAME.THREE.LineBasicMaterial({ 
                        color: COLOR_DEFAULT_ZONE,
                        linewidth: 2,
                        depthTest: true // 建议开启深度测试，确保AR空间遮挡正确
                    });
                    
                    silhouetteLine = new AFRAME.THREE.LineSegments(geometry, material);
                    silhouetteLine.name = 'silhouetteLine';
                    mesh.add(silhouetteLine);
                }
            }
        });

        AFRAME.registerComponent('magic-window-sync', {
            init: function() { this.invMat = new AFRAME.THREE.Matrix4(); },
            tick: function() {
                if (!isMagicWindowVisible || !this.el.object3D) return;
                this.el.object3D.updateMatrixWorld();
                this.invMat.copy(this.el.object3D.matrixWorld).invert();
                const scale = this.el.object3D.scale;
                for (let i = 0; i < magicObjects.length; i++) {
                    magicObjects[i].updateWindowParams(this.invMat, scale);
                }
            }
        });

        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            this.lastPinchTime = 0;
            this.sceneEl = document.querySelector('a-scene');
            this.el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < 300) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else { this.lastPinchTime = currentTime; }
            });
          },
          handleDoublePinch: function (pinchPos) {
            const rightHand = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightHand ? rightHand.grabbedEl : null;
            if (grabbedEl && grabbedEl.hasAttribute('grabbable') && !grabbedEl.classList.contains('magic-window')) {
                if (grabbedEl.parentNode) grabbedEl.parentNode.removeChild(grabbedEl);
            } else { this.createRandomElement(pinchPos); }
          },
          createRandomElement: function (pos) {
            const el = document.createElement(Math.random() < 0.5 ? 'a-box' : 'a-sphere');
            const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            if (el.tagName === 'A-BOX') el.setAttribute('depth', ELEMENT_SIZE);
            else el.setAttribute('radius', ELEMENT_SIZE/2);
            el.setAttribute('width', ELEMENT_SIZE); el.setAttribute('height', ELEMENT_SIZE);
            el.setAttribute('apply-magic-shader', `color: ${color}`);
            el.setAttribute('grabbable', ''); 
            el.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
            this.sceneEl.appendChild(el);
          }
        });

        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.sceneEl = document.querySelector('a-scene'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false; this.isRightPinching = false;
                this.isCreating = false; this.windowEl = null;

                const start = () => { this.checkStart(); };
                const end = () => { this.isLeftPinching = false; this.isRightPinching = false; clearTimeout(this.timeout); this.isCreating = false; };
                
                this.leftHand.addEventListener('pinchstarted', () => { this.isLeftPinching = true; start(); });
                this.leftHand.addEventListener('pinchended', end);
                this.rightHand.addEventListener('pinchstarted', () => { this.isRightPinching = true; start(); });
                this.rightHand.addEventListener('pinchended', end);
            },
            checkStart: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) this.toggleMagicWindow();
                    }, 3000);
                }
            },
            showStatusText: function(message) {
                const textEl = document.createElement('a-text');
                textEl.setAttribute('value', message); textEl.setAttribute('position', '0 2.0 -1.5'); 
                textEl.setAttribute('align', 'center'); textEl.setAttribute('look-at', '#mainCamera'); 
                this.sceneEl.appendChild(textEl);
                setTimeout(() => { if (textEl.parentNode) textEl.parentNode.removeChild(textEl); }, 2000);
            },
            toggleMagicWindow: function() {
                if (isMagicWindowVisible) {
                    if (this.windowEl) this.windowEl.parentNode.removeChild(this.windowEl);
                    isMagicWindowVisible = false;
                    this.showStatusText("Magic View Deleted");
                } else {
                    const camEl = document.getElementById('mainCamera');
                    const pos = new AFRAME.THREE.Vector3(0, 0, -0.5);
                    pos.applyMatrix4(camEl.object3D.matrixWorld);

                    this.windowEl = document.createElement('a-entity');
                    this.windowEl.setAttribute('position', pos); 
                    this.windowEl.setAttribute('grabbable', '');
                    this.windowEl.setAttribute('class', 'magic-window');
                    this.windowEl.setAttribute('magic-window-sync', '');
                    this.windowEl.setAttribute('dynamic-silhouette', ''); // 添加动态轮廓组件
                    
                    this.windowEl.addEventListener('loaded', () => {
                        const boxGeometry = new AFRAME.THREE.BoxGeometry(
                            WINDOW_BOX_SIZE.w, 
                            WINDOW_BOX_SIZE.h, 
                            WINDOW_BOX_SIZE.d
                        );
                        
                        const boxMaterial = new AFRAME.THREE.MeshBasicMaterial({
                            color: COLOR_DEFAULT_ZONE,
                            transparent: true,
                            opacity: 0.05,
                            side: AFRAME.THREE.DoubleSide
                        });
                        const boxMesh = new AFRAME.THREE.Mesh(boxGeometry, boxMaterial);
                        
                        this.windowEl.setObject3D('mesh', boxMesh);
                        this.windowEl.object3D.lookAt(camEl.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
                    });
                    
                    this.sceneEl.appendChild(this.windowEl); 
                    isMagicWindowVisible = true;
                    this.showStatusText("Magic View Created");
                }
                magicObjects.forEach(cmp => cmp.setWindowActive(isMagicWindowVisible));
            }
        });
    </script>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <a-scene xr-mode-ui="XRMode: ar"> 
        <a-camera id="mainCamera" position="0 1.6 0"></a-camera>
        <a-box position="0 1.2 -0.2" rotation="0 45 0" width="0.1" height="0.1" depth="0.1" apply-magic-shader="color: #FF0000" grabbable></a-box>
        <a-sphere position="0 1.2 -2.0" radius="0.1" apply-magic-shader="color: #00FF00" grabbable></a-sphere>
        
        <a-entity id="leftHand" hand-tracking-controls="hand: left" double-pinch-creator-deleter magic-window-creator></a-entity>
        <a-entity id="rightHand" hand-tracking-controls="hand: right" hand-tracking-grab-controls="hand: right; hoverEnabled: true;"></a-entity>
    </a-scene>
</body>
</html>