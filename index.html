<!DOCTYPE html>
<html>
<head>
    <title>A-Frame AR Magic Window (Shader Fixed)</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition; 

        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec3 uBaseColor;
        
        // --- 修改点 1：增加控制开关 ---
        uniform float uWindowActive; // 1.0 = 显示/生效, 0.0 = 不显示/不生效

        const float WINDOW_Z = -0.5;
        const float WINDOW_WIDTH = 0.4;
        const float WINDOW_HEIGHT = 0.3;
        const float SHRINK_FACTOR = 0.9; 
        const float OPACITY_TRANSPARENT = 0.2;
        const float OPACITY_OPAQUE = 1.0;

        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        void main() {
            vec3 lightDir = normalize(vec3(0.5, 0.8, 1.0));
            float diff = max(dot(vNormal, lightDir), 0.0);
            vec3 finalColor = uBaseColor * (0.5 + 0.5 * diff);

            float alpha = OPACITY_OPAQUE;

            // --- 修改点 2：只有当 Window 激活时才计算透明度 ---
            if (uWindowActive > 0.5) {
                // 核心逻辑：深度检查
                if (vViewPosition.z < WINDOW_Z) {
                    float projectionFactor = WINDOW_Z / vViewPosition.z;
                    float projectedX = vViewPosition.x * projectionFactor;
                    float projectedY = vViewPosition.y * projectionFactor;

                    float limitX = (WINDOW_WIDTH / 2.0) * SHRINK_FACTOR;
                    float limitY = (WINDOW_HEIGHT / 2.0) * SHRINK_FACTOR;

                    if (abs(projectedX) <= limitX && abs(projectedY) <= limitY) {
                        alpha = OPACITY_TRANSPARENT;
                    }
                }
            }

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        // 常量定义
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const MAGIC_WINDOW_Z_POS = -0.5; 
        const ELEMENT_SIZE = 0.1; 

        // --- 修改点 3：全局变量记录窗口状态 ---
        let isMagicWindowVisible = false;

        // === 组件：应用 Magic Shader ===
        AFRAME.registerComponent('apply-magic-shader', {
            schema: {
                color: {type: 'color', default: '#FFFFFF'}
            },
            
            init: function() {
                const vShader = document.getElementById('vertexShader').textContent;
                const fShader = document.getElementById('fragmentShader').textContent;
                
                this.material = new AFRAME.THREE.ShaderMaterial({
                    vertexShader: vShader,
                    fragmentShader: fShader,
                    uniforms: {
                        uBaseColor: { value: new AFRAME.THREE.Color(this.data.color) },
                        // 初始化时根据全局状态设置
                        uWindowActive: { value: isMagicWindowVisible ? 1.0 : 0.0 }
                    },
                    transparent: true,
                    side: AFRAME.THREE.DoubleSide
                });

                const mesh = this.el.getObject3D('mesh');
                if (mesh) {
                    mesh.material = this.material;
                } else {
                    this.el.addEventListener('model-loaded', () => {
                        const mesh = this.el.getObject3D('mesh');
                        if (mesh) mesh.material = this.material;
                    });
                    setTimeout(() => {
                         const mesh = this.el.getObject3D('mesh');
                         if (mesh) mesh.material = this.material;
                    }, 100);
                }
            },

            update: function() {
                if (this.material) {
                    this.material.uniforms.uBaseColor.value.set(this.data.color);
                }
            },

            // --- 修改点 4：供外部调用的更新方法 ---
            setWindowActive: function(isActive) {
                if (this.material) {
                    this.material.uniforms.uWindowActive.value = isActive ? 1.0 : 0.0;
                    this.material.needsUpdate = true;
                }
            }
        });

        // === 组件：双捏合创建/删除 (保持原样) ===
        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            const el = this.el; 
            this.lastPinchTime = 0;
            this.doubleClickThreshold = 300; 
            this.sceneEl = document.querySelector('a-scene');

            el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < this.doubleClickThreshold) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else {
                this.lastPinchTime = currentTime;
              }
            });
          },
          
          handleDoublePinch: function (pinchWorldPosition) {
            const rightGrabControls = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightGrabControls ? rightGrabControls.grabbedEl : null;
            
            if (grabbedEl && grabbedEl.hasAttribute('grabbable')) {
              if (grabbedEl.parentNode) {
                grabbedEl.parentNode.removeChild(grabbedEl);
              }
            } else {
              this.createRandomElement(pinchWorldPosition);
            }
          },
          
          createRandomElement: function (pinchWorldPosition) {
            const isBox = Math.random() < 0.5; 
            let newElement;
            const randomColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;

            if (isBox) {
                newElement = document.createElement('a-box');
                newElement.setAttribute('depth', ELEMENT_SIZE); 
            } else {
                newElement = document.createElement('a-plane');
                newElement.setAttribute('rotation', '0 0 0'); 
            }
            
            newElement.setAttribute('width', ELEMENT_SIZE);
            newElement.setAttribute('height', ELEMENT_SIZE);
            newElement.setAttribute('apply-magic-shader', `color: ${randomColor}`);
            newElement.setAttribute('shadow', '');
            newElement.setAttribute('grabbable', ''); 
            newElement.setAttribute('position', `${pinchWorldPosition.x} ${pinchWorldPosition.y} ${pinchWorldPosition.z}`);
            
            this.sceneEl.appendChild(newElement);
          }
        });

        // === 组件：Magic Window 线框创建 (修改为切换模式) ===
        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.cameraAnchorEl = document.getElementById('cameraAnchor'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false;
                this.isRightPinching = false;
                this.creationThreshold = 3000; 
                this.isCreating = false;

                this.leftHand.addEventListener('pinchstarted', (evt) => { this.isLeftPinching = true; this.checkStartCreation(); });
                this.leftHand.addEventListener('pinchended', () => { this.isLeftPinching = false; this.checkEndCreation(); });
                this.rightHand.addEventListener('pinchstarted', (evt) => { this.isRightPinching = true; this.checkStartCreation(); });
                this.rightHand.addEventListener('pinchended', () => { this.isRightPinching = false; this.checkEndCreation(); });
            },

            checkStartCreation: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) {
                            // --- 修改点 5：改为调用 Toggle ---
                            this.toggleMagicWindow();
                            this.isCreating = false;
                        }
                    }, this.creationThreshold);
                }
            },

            checkEndCreation: function() {
                if (!this.isLeftPinching || !this.isRightPinching) {
                    clearTimeout(this.timeout);
                    this.isCreating = false;
                }
            },

            // --- 修改点 6：实现切换逻辑 ---
            toggleMagicWindow: function() {
                // 检查窗口是否存在
                const existingWindow = this.cameraAnchorEl.firstElementChild;

                if (existingWindow) {
                    // 1. 删除可视化窗口
                    this.cameraAnchorEl.innerHTML = '';
                    console.log('Magic Window DEACTIVATED');
                    
                    // 2. 更新状态
                    isMagicWindowVisible = false;
                } else {
                    // 1. 创建可视化窗口
                    const newWindow = document.createElement('a-entity');
                    newWindow.setAttribute('magic-window', ''); 
                    newWindow.setAttribute('geometry', 'primitive: plane; width: 0.4; height: 0.3;'); 
                    newWindow.setAttribute('position', `0 0 ${MAGIC_WINDOW_Z_POS}`); 
                    newWindow.setAttribute('material', `color: ${COLOR_DEFAULT_ZONE}; wireframe: true; transparent: true; opacity: 1.0;`); 
                    this.cameraAnchorEl.appendChild(newWindow); 
                    console.log('Magic Window ACTIVATED');

                    // 2. 更新状态
                    isMagicWindowVisible = true;
                }

                // 3. 通知所有现有的物体更新 Shader
                const allObjects = document.querySelectorAll('[apply-magic-shader]');
                allObjects.forEach(el => {
                    if (el.components['apply-magic-shader']) {
                        el.components['apply-magic-shader'].setWindowActive(isMagicWindowVisible);
                    }
                });
            }
        });

    </script>
    
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    
    <a-scene xr-mode-ui="XRMode: ar"> 
        
        <a-camera id="mainCamera">
            <a-entity id="cameraAnchor"></a-entity>
        </a-camera>
        
        <a-box 
            position="0 1.0 -0.6" 
            rotation="0 45 0" 
            width="0.1" 
            height="0.1" 
            depth="0.1" 
            apply-magic-shader="color: #FF0000"
            shadow
            grabbable> 
        </a-box>

        <a-entity 
            id="leftHand" 
            hand-tracking-controls="hand: left"
            double-pinch-creator-deleter
            magic-window-creator>
        </a-entity>

        <a-entity 
            id="rightHand" 
            hand-tracking-controls="hand: right"
            hand-tracking-grab-controls="hand: right; hoverEnabled: true;">
        </a-entity>
        
        <a-entity light="type: point; intensity: 1.5; decay: 2; color: #FFFFFF;" position="0 1 0"></a-entity>
        <a-entity light="type: ambient; intensity: 0.5;"></a-entity>

    </a-scene>

</body>
</html>