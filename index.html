<!DOCTYPE html>
<html>
<head>
    <title>A-Frame 1.7.0 AR 最终稳定版 - Magic Window 修复 (相交模式)</title>
    
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    
    <script>
        // 常量定义
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const TRANSPARENT_OPACITY = 0.2; 
        const OPAQUE_OPACITY = 1.0;      
        const MAGIC_WINDOW_Z_POS = -0.5; 

        // --- THREE.js 辅助对象 (避免在 tick 中重复创建) ---
        const tempVector = new AFRAME.THREE.Vector3();
        const box3 = new AFRAME.THREE.Box3();
        const boxVertices = [
            new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(),
            new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(),
        ];


        // === 1. 双捏合创建/删除组件 (Double Pinch Creator/Deleter) - 不变 ===
        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            const el = this.el; 
            this.lastPinchTime = 0;
            this.doubleClickThreshold = 300; 
            this.sceneEl = document.querySelector('a-scene');

            el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < this.doubleClickThreshold) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else {
                this.lastPinchTime = currentTime;
              }
            });
          },
          
          handleDoublePinch: function (pinchWorldPosition) {
            const rightGrabControls = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightGrabControls ? rightGrabControls.grabbedEl : null;

            if (grabbedEl && grabbedEl.hasAttribute('grabbable')) {
              console.log('Entity deleted via left hand double pinch confirmation!');
              if (grabbedEl.parentNode) {
                grabbedEl.parentNode.removeChild(grabbedEl);
              }
            } else {
              this.createBox(pinchWorldPosition);
            }
          },
          
          createBox: function (pinchWorldPosition) {
            const newBox = document.createElement('a-box');
            newBox.setAttribute('width', 0.1);
            newBox.setAttribute('height', 0.1);
            newBox.setAttribute('depth', 0.1);
            newBox.setAttribute('color', `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`); 
            newBox.setAttribute('shadow', '');
            newBox.setAttribute('grabbable', ''); 
            newBox.setAttribute('material', 'transparent: true; opacity: 1.0;'); 
            newBox.setAttribute('position', `${pinchWorldPosition.x} ${pinchWorldPosition.y} ${pinchWorldPosition.z}`);
            this.sceneEl.appendChild(newBox);
            console.log('New box created via left hand double pinch!');
          }
        });

        // === 2. Magic Window 创建组件 - 不变 ===
        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.cameraAnchorEl = document.getElementById('cameraAnchor'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false;
                this.isRightPinching = false;
                this.creationThreshold = 3000; 
                this.isCreating = false;

                this.leftHand.addEventListener('pinchstarted', (evt) => { this.isLeftPinching = true; this.checkStartCreation(); });
                this.leftHand.addEventListener('pinchended', () => { this.isLeftPinching = false; this.checkEndCreation(); });
                this.rightHand.addEventListener('pinchstarted', () => { this.isRightPinching = true; this.checkStartCreation(); });
                this.rightHand.addEventListener('pinchended', () => { this.isRightPinching = false; this.checkEndCreation(); });
            },

            checkStartCreation: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) {
                            this.createMagicWindow();
                            this.isCreating = false;
                        }
                    }, this.creationThreshold);
                }
            },

            checkEndCreation: function() {
                if (!this.isLeftPinching || !this.isRightPinching) {
                    clearTimeout(this.timeout);
                    this.isCreating = false;
                }
            },

            createMagicWindow: function() {
                const newWindow = document.createElement('a-entity');
                newWindow.setAttribute('magic-window', ''); 
                newWindow.setAttribute('grabbable', ''); 
                
                newWindow.setAttribute('geometry', 'primitive: plane; width: 0.4; height: 0.3;'); 
                newWindow.setAttribute('position', `0 -0.1 ${MAGIC_WINDOW_Z_POS}`); 
                newWindow.setAttribute('material', `color: ${COLOR_DEFAULT_ZONE}; wireframe: true; transparent: true; opacity: 1.0;`); 
                
                this.cameraAnchorEl.appendChild(newWindow); 
                console.log('Magic Window created and anchored to camera!');
            }
        });


        // === 3. Box 剪裁视觉化组件 (Box Cull Visualizer) - 修复为相交模式 ===
        AFRAME.registerComponent('box-cull-visualizer', {
            init: function() {
                this.sceneEl = this.el;
                this.cameraEl = document.getElementById('mainCamera');
                this.windowEl = null; 
            },

            /**
             * 检查 Box 是否部分或完全在 Magic Window 的视锥体中。
             * 逻辑已修改为：只要有一个 Box 的顶点满足深度和投影条件，即视为相交。
             */
            isBoxFullyContained(boxEl, windowEl) {
                const boxObj = boxEl.object3D;
                if (!boxObj || !this.cameraEl.object3D) return false;

                const boxMesh = boxEl.getObject3D('mesh');
                if (!boxMesh || !boxMesh.geometry) {
                    return false;
                }
                
                // 1. 获取 Box 的世界边界框 (World AABB)
                boxObj.updateMatrixWorld(true);
                box3.setFromObject(boxMesh); 
                
                if (box3.isEmpty()) {
                    return false;
                }
                
                // --- 手动计算 Box3 的 8 个顶点 ---
                const min = box3.min;
                const max = box3.max;
                
                boxVertices[0].set(min.x, min.y, min.z);
                boxVertices[1].set(max.x, min.y, min.z);
                boxVertices[2].set(min.x, max.y, min.z);
                boxVertices[3].set(max.x, max.y, min.z);
                
                boxVertices[4].set(min.x, min.y, max.z);
                boxVertices[5].set(max.x, min.y, max.z);
                boxVertices[6].set(min.x, max.y, max.z);
                boxVertices[7].set(max.x, max.y, max.z);
                // ------------------------------------
                
                
                // 2. Magic Window 参数
                const windowWidth = 0.4;
                const windowHeight = 0.3;
                const windowZ = MAGIC_WINDOW_Z_POS;
                const windowCenterYLocal = -0.1; 

                // 3. 检查 Box 的 8 个顶点中是否有任何一个满足相交条件
                let isContained = false; // 初始假设不相交
                
                for (let i = 0; i < 8; i++) {
                    const vertexWorld = boxVertices[i];
                    
                    // a) 转换顶点到 Camera 局部空间
                    tempVector.copy(vertexWorld);
                    this.cameraEl.object3D.worldToLocal(tempVector);

                    const vx = tempVector.x;
                    const vy = tempVector.y;
                    const vz = tempVector.z; 

                    // b) 深度检查 (必须在 Window 后面)
                    if (vz > windowZ + 0.001) { 
                        // 此顶点在 Window 前面，不考虑相交
                        continue; 
                    }

                    // c) 投影检查
                    // Z 必须是负数
                    if (vz >= 0) {
                        continue; 
                    }
                    
                    const projectionFactor = windowZ / vz; 

                    const projectedX = vx * projectionFactor;
                    const projectedY = vy * projectionFactor;
                    
                    const halfWidth = windowWidth / 2;
                    const halfHeight = windowHeight / 2;
                    
                    const windowCenterYProjected = windowCenterYLocal * projectionFactor;
                    
                    // 检查投影是否在 Window 矩形范围内
                    if (projectedX >= -halfWidth && projectedX <= halfWidth &&
                        projectedY >= (windowCenterYProjected - halfHeight) && projectedY <= (windowCenterYProjected + halfHeight)) 
                    {
                        // 找到一个满足条件的顶点，视为相交
                        isContained = true; 
                        break; // 找到一个即可，跳出循环
                    }
                }

                // 返回判断结果
                return isContained;
            },

            tick: function() {
                const windowEls = this.sceneEl.querySelectorAll('[magic-window]');
                const boxEls = this.sceneEl.querySelectorAll('a-box[grabbable]:not([magic-window])');

                if (boxEls.length === 0) return;

                boxEls.forEach(boxEl => {
                    let isContainedInAnyWindow = false;

                    // 检查 Box 是否与任何一个 Magic Window 的视锥体相交
                    for (let i = 0; i < windowEls.length; i++) {
                        // isBoxFullyContained 现在执行的是相交测试
                        if (this.isBoxFullyContained(boxEl, windowEls[i])) { 
                            isContainedInAnyWindow = true;
                            break; 
                        }
                    }

                    // 设置透明度
                    const currentOpacity = boxEl.getAttribute('material').opacity;
                    
                    if (isContainedInAnyWindow) {
                        if (currentOpacity !== TRANSPARENT_OPACITY) {
                            boxEl.setAttribute('material', 'opacity', TRANSPARENT_OPACITY);
                            boxEl.setAttribute('material', 'transparent', true); 
                        }
                    } else {
                        if (currentOpacity !== OPAQUE_OPACITY) {
                            boxEl.setAttribute('material', 'opacity', OPAQUE_OPACITY);
                            boxEl.setAttribute('material', 'transparent', true); 
                        }
                    }
                });
            }
        });

    </script>
    
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    
    <a-scene xr-mode-ui="XRMode: ar" box-cull-visualizer> 
        
        <a-camera id="mainCamera">
            <a-entity id="cameraAnchor"></a-entity>
        </a-camera>
        
        <a-box 
            position="0 1.0 -0.6" 
            rotation="0 45 0" 
            width="0.1" 
            height="0.1" 
            depth="0.1" 
            color="#FF0000"
            shadow
            grabbable
            material="transparent: true; opacity: 1.0;"> 
        </a-box>

        <a-entity 
            id="leftHand" 
            hand-tracking-controls="hand: left"
            double-pinch-creator-deleter
            magic-window-creator>
        </a-entity>

        <a-entity 
            id="rightHand" 
            hand-tracking-controls="hand: right"
            hand-tracking-grab-controls="hand: right; hoverEnabled: true;">
        </a-entity>
        
        <a-entity light="type: point; intensity: 1.5; decay: 2; color: #FFFFFF;" position="0 1 0"></a-entity>
        <a-entity light="type: ambient; intensity: 0.5;"></a-entity>

    </a-scene>

</body>
</html>