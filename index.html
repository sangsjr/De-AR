<!DOCTYPE html>
<html>
<head>
    <title>A-Frame 1.7.0 AR 最终稳定版 - Magic Window 2D/3D 混合元素 (收缩范围)</title>
    
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    
    <script>
        // 常量定义
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const TRANSPARENT_OPACITY = 0.2; 
        const OPAQUE_OPACITY = 1.0;      
        const MAGIC_WINDOW_Z_POS = -0.5; 
        const ELEMENT_SIZE = 0.1; 
        
        // 范围调整常量
        const SHRINK_FACTOR = 0.9; // 新增：将检测范围收缩 10% (0.9)，以弥补相交检测的视觉扩大效应

        // --- THREE.js 辅助对象 (不变) ---
        const tempVector = new AFRAME.THREE.Vector3();
        const box3 = new AFRAME.THREE.Box3();
        const boxVertices = [
            new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(),
            new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(), new AFRAME.THREE.Vector3(),
        ];
        // ... (其他不变的代码)


        // === 1. 双捏合创建/删除组件 (Double Pinch Creator/Deleter) - 不变 ===
        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            const el = this.el; 
            this.lastPinchTime = 0;
            this.doubleClickThreshold = 300; 
            this.sceneEl = document.querySelector('a-scene');

            el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < this.doubleClickThreshold) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else {
                this.lastPinchTime = currentTime;
              }
            });
          },
          
          handleDoublePinch: function (pinchWorldPosition) {
            const rightGrabControls = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightGrabControls ? rightGrabControls.grabbedEl : null;
            
            if (grabbedEl && grabbedEl.hasAttribute('grabbable')) {
              console.log('Entity deleted via left hand double pinch confirmation!');
              if (grabbedEl.parentNode) {
                grabbedEl.parentNode.removeChild(grabbedEl);
              }
            } else {
              this.createRandomElement(pinchWorldPosition);
            }
          },
          
          createRandomElement: function (pinchWorldPosition) {
            const isBox = Math.random() < 0.5; 
            let newElement;

            if (isBox) {
                newElement = document.createElement('a-box');
                newElement.setAttribute('depth', ELEMENT_SIZE); 
            } else {
                newElement = document.createElement('a-plane');
                newElement.setAttribute('rotation', '0 0 0'); 
            }
            
            newElement.setAttribute('width', ELEMENT_SIZE);
            newElement.setAttribute('height', ELEMENT_SIZE);
            newElement.setAttribute('color', `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`); 
            newElement.setAttribute('shadow', '');
            newElement.setAttribute('grabbable', ''); 
            newElement.setAttribute('material', 'transparent: true; opacity: 1.0; side: double;'); 
            newElement.setAttribute('position', `${pinchWorldPosition.x} ${pinchWorldPosition.y} ${pinchWorldPosition.z}`);
            
            this.sceneEl.appendChild(newElement);
            console.log(`New ${isBox ? 'Box (3D)' : 'Plane (2D)'} created via left hand double pinch!`);
          }
        });

        // === 2. Magic Window 创建组件 - 不变 ===
        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.cameraAnchorEl = document.getElementById('cameraAnchor'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false;
                this.isRightPinching = false;
                this.creationThreshold = 3000; 
                this.isCreating = false;

                this.leftHand.addEventListener('pinchstarted', (evt) => { this.isLeftPinching = true; this.checkStartCreation(); });
                this.leftHand.addEventListener('pinchended', () => { this.isLeftPinching = false; this.checkEndCreation(); });
                this.rightHand.addEventListener('pinchstarted', () => { this.isRightPinching = true; this.checkStartCreation(); });
                this.rightHand.addEventListener('pinchended', () => { this.isRightPinching = false; this.checkEndCreation(); });
            },

            checkStartCreation: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) {
                            this.createMagicWindow();
                            this.isCreating = false;
                        }
                    }, this.creationThreshold);
                }
            },

            checkEndCreation: function() {
                if (!this.isLeftPinching || !this.isRightPinching) {
                    clearTimeout(this.timeout);
                    this.isCreating = false;
                }
            },

            createMagicWindow: function() {
                const newWindow = document.createElement('a-entity');
                newWindow.setAttribute('magic-window', ''); 
                newWindow.setAttribute('grabbable', ''); 
                
                newWindow.setAttribute('geometry', 'primitive: plane; width: 0.4; height: 0.3;'); 
                newWindow.setAttribute('position', `0 0 ${MAGIC_WINDOW_Z_POS}`); 
                newWindow.setAttribute('material', `color: ${COLOR_DEFAULT_ZONE}; wireframe: true; transparent: true; opacity: 1.0;`); 
                newWindow.setAttribute('scale', '1 1 1'); 
                
                this.cameraAnchorEl.appendChild(newWindow); 
                console.log('Magic Window created and anchored to camera!');
            }
        });


        // === 3. 元素剔除视觉化组件 (Cull Visualizer) - 修复投影范围 ===
        AFRAME.registerComponent('box-cull-visualizer', {
            init: function() {
                this.sceneEl = this.el;
                this.cameraEl = document.getElementById('mainCamera');
                this.windowEl = null; 
            },

            isElementContained(el, windowEl) {
                const elObj = el.object3D;
                if (!elObj || !this.cameraEl.object3D) return false;

                const elMesh = el.getObject3D('mesh');
                if (!elMesh || !elMesh.geometry) {
                    return false;
                }
                
                elObj.updateMatrixWorld(true);
                box3.setFromObject(elMesh); 
                
                if (box3.isEmpty()) {
                    return false;
                }
                
                // --- 手动计算 Box3 的 8 个顶点 (不变) ---
                const min = box3.min;
                const max = box3.max;
                
                boxVertices[0].set(min.x, min.y, min.z);
                boxVertices[1].set(max.x, min.y, min.z);
                boxVertices[2].set(min.x, max.y, min.z);
                boxVertices[3].set(max.x, max.y, min.z);
                
                boxVertices[4].set(min.x, min.y, max.z);
                boxVertices[5].set(max.x, min.y, max.z);
                boxVertices[6].set(min.x, max.y, max.z);
                boxVertices[7].set(max.x, max.y, max.z);
                // ------------------------------------
                
                
                // 2. Magic Window 参数
                const windowWidth = 0.4;
                const windowHeight = 0.3;
                const windowZ = MAGIC_WINDOW_Z_POS;
                const windowCenterYLocal = 0; 

                // *** 核心修改：应用收缩因子 ***
                const adjustedHalfWidth = (windowWidth / 2) * SHRINK_FACTOR;
                const adjustedHalfHeight = (windowHeight / 2) * SHRINK_FACTOR;

                // 3. 检查 8 个顶点中是否有任何一个满足相交条件
                let isContained = false; 
                
                for (let i = 0; i < 8; i++) {
                    const vertexWorld = boxVertices[i];
                    
                    // a) 转换顶点到 Camera 局部空间
                    tempVector.copy(vertexWorld);
                    this.cameraEl.object3D.worldToLocal(tempVector);

                    const vx = tempVector.x;
                    const vy = tempVector.y;
                    const vz = tempVector.z; 

                    // b) 深度检查 (使用微小容差)
                    if (vz > windowZ + 0.001) { 
                        continue; 
                    }

                    // c) 投影检查
                    if (vz >= 0) {
                        continue; 
                    }
                    
                    const projectionFactor = windowZ / vz; 

                    const projectedX = vx * projectionFactor;
                    const projectedY = vy * projectionFactor;
                    
                    const windowCenterYProjected = windowCenterYLocal * projectionFactor;
                    
                    // 检查投影是否在调整后的 Window 矩形范围内
                    if (projectedX >= -adjustedHalfWidth && projectedX <= adjustedHalfWidth &&
                        projectedY >= (windowCenterYProjected - adjustedHalfHeight) && projectedY <= (windowCenterYProjected + adjustedHalfHeight)) 
                    {
                        isContained = true; 
                        break; 
                    }
                }

                return isContained;
            },

            tick: function() {
                const windowEls = this.sceneEl.querySelectorAll('[magic-window]');
                const targetEls = this.sceneEl.querySelectorAll('a-box[grabbable]:not([magic-window]), a-plane[grabbable]:not([magic-window])');

                if (targetEls.length === 0) return;

                targetEls.forEach(el => {
                    let isContainedInAnyWindow = false;

                    for (let i = 0; i < windowEls.length; i++) {
                        if (this.isElementContained(el, windowEls[i])) { 
                            isContainedInAnyWindow = true;
                            break; 
                        }
                    }

                    const currentMaterial = el.getAttribute('material');
                    const currentOpacity = currentMaterial.opacity;
                    
                    if (isContainedInAnyWindow) {
                        if (currentOpacity !== TRANSPARENT_OPACITY) {
                            el.setAttribute('material', {opacity: TRANSPARENT_OPACITY, transparent: true, side: currentMaterial.side || 'double'}); 
                        }
                    } else {
                        if (currentOpacity !== OPAQUE_OPACITY) {
                            el.setAttribute('material', {opacity: OPAQUE_OPACITY, transparent: true, side: currentMaterial.side || 'double'});
                        }
                    }
                });
            }
        });

    </script>
    
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    
    <a-scene xr-mode-ui="XRMode: ar" box-cull-visualizer> 
        
        <a-camera id="mainCamera">
            <a-entity id="cameraAnchor"></a-entity>
        </a-camera>
        
        <a-box 
            position="0 1.0 -0.6" 
            rotation="0 45 0" 
            width="0.1" 
            height="0.1" 
            depth="0.1" 
            color="#FF0000"
            shadow
            grabbable
            material="transparent: true; opacity: 1.0;"> 
        </a-box>

        <a-entity 
            id="leftHand" 
            hand-tracking-controls="hand: left"
            double-pinch-creator-deleter
            magic-window-creator>
        </a-entity>

        <a-entity 
            id="rightHand" 
            hand-tracking-controls="hand: right"
            hand-tracking-grab-controls="hand: right; hoverEnabled: true;">
        </a-entity>
        
        <a-entity light="type: point; intensity: 1.5; decay: 2; color: #FFFFFF;" position="0 1 0"></a-entity>
        <a-entity light="type: ambient; intensity: 0.5;"></a-entity>

    </a-scene>

</body>
</html>