<!DOCTYPE html>
<html>
<head>
    <title>A-Frame AR Magic Volume - Near Clipping</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vWorldPosition; 
        void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec3 uBaseColor;
        uniform float uWindowActive; 
        uniform mat4 uWindowInvMat; 
        uniform vec3 uBoxDim; 
        uniform vec3 uBoxScale; 
        uniform vec3 uCameraWorldPos; 

        varying vec3 vWorldPosition; 

        // 射线与 AABB（轴对齐包围盒）求交函数
        vec2 rayBoxIntersection(vec3 ro, vec3 rd, vec3 halfDim) {
            vec3 m = 1.0 / rd;
            vec3 n = m * ro;
            vec3 k = abs(m) * halfDim;
            vec3 t1 = -n - k;
            vec3 t2 = -n + k;
            float tNear = max(max(t1.x, t1.y), t1.z);
            float tFar = min(min(t2.x, t2.y), t2.z);
            return vec2(tNear, tFar);
        }

        void main() {
            vec3 finalColor = uBaseColor; 
            float alpha = 1.0;

            if (uWindowActive > 0.5) {
                vec3 worldDir = normalize(vWorldPosition - uCameraWorldPos);
                vec3 ro = (uWindowInvMat * vec4(uCameraWorldPos, 1.0)).xyz;
                vec3 rd = normalize((uWindowInvMat * vec4(worldDir, 0.0)).xyz);
                vec3 halfDim = (uBoxDim * uBoxScale) * 0.5;

                vec2 hit = rayBoxIntersection(ro, rd, halfDim);
                float tNear = hit.x;
                float tFar = hit.y;

                // 判定逻辑：
                // 1. 射线必须撞击到立方体区域 (tNear < tFar)
                // 2. 立方体必须在相机视线前方 (tFar > 0.0)
                if (tNear < tFar && tFar > 0.0) {
                    float distToObj = distance(uCameraWorldPos, vWorldPosition);
                    
                    // 修正点：变透明的范围是相机到立方体远端的距离
                    // 只要物体像素距离相机的距离 小于 视线穿透立方体出口的距离，就变透明
                    if (distToObj < tFar) {
                        alpha = 0.2;
                    }
                }
            }
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const ELEMENT_SIZE = 0.1; 
        const WINDOW_BOX_SIZE = { w: 0.4, h: 0.3, d: 0.4 }; 

        let isMagicWindowVisible = false;
        let magicObjects = [];

        AFRAME.registerComponent('apply-magic-shader', {
            schema: { color: {type: 'color', default: '#FFFFFF'} },
            init: function() {
                magicObjects.push(this);
                this.cameraPos = new AFRAME.THREE.Vector3();
                this.material = new AFRAME.THREE.ShaderMaterial({
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                    uniforms: {
                        uBaseColor: { value: new AFRAME.THREE.Color(this.data.color) },
                        uWindowActive: { value: isMagicWindowVisible ? 1.0 : 0.0 },
                        uWindowInvMat: { value: new AFRAME.THREE.Matrix4() }, 
                        uBoxDim: { value: new AFRAME.THREE.Vector3(WINDOW_BOX_SIZE.w, WINDOW_BOX_SIZE.h, WINDOW_BOX_SIZE.d) },
                        uBoxScale: { value: new AFRAME.THREE.Vector3(1, 1, 1) },
                        uCameraWorldPos: { value: this.cameraPos }
                    },
                    transparent: true,
                    side: AFRAME.THREE.DoubleSide
                });

                const applyMat = () => {
                    const mesh = this.el.getObject3D('mesh');
                    if (mesh) mesh.material = this.material;
                };
                if (this.el.getObject3D('mesh')) applyMat();
                else this.el.addEventListener('model-loaded', applyMat);
            },
            tick: function() {
                const cam = this.el.sceneEl.camera;
                if (cam) { cam.getWorldPosition(this.cameraPos); }
            },
            remove: function() {
                const index = magicObjects.indexOf(this);
                if (index > -1) magicObjects.splice(index, 1);
            },
            setWindowActive: function(isActive) {
                if (this.material) this.material.uniforms.uWindowActive.value = isActive ? 1.0 : 0.0;
            },
            updateWindowParams: function(invMat, scale) {
                if (this.material) {
                    this.material.uniforms.uWindowInvMat.value.copy(invMat);
                    this.material.uniforms.uBoxScale.value.copy(scale);
                }
            }
        });

        AFRAME.registerComponent('magic-window-sync', {
            init: function() { this.invMat = new AFRAME.THREE.Matrix4(); },
            tick: function() {
                if (!isMagicWindowVisible || !this.el.object3D) return;
                this.el.object3D.updateMatrixWorld();
                this.invMat.copy(this.el.object3D.matrixWorld).invert();
                const scale = this.el.object3D.scale;
                for (let i = 0; i < magicObjects.length; i++) {
                    magicObjects[i].updateWindowParams(this.invMat, scale);
                }
            }
        });

        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            this.lastPinchTime = 0;
            this.sceneEl = document.querySelector('a-scene');
            this.el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < 300) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else { this.lastPinchTime = currentTime; }
            });
          },
          handleDoublePinch: function (pinchPos) {
            const rightHand = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightHand ? rightHand.grabbedEl : null;
            if (grabbedEl && grabbedEl.hasAttribute('grabbable') && !grabbedEl.classList.contains('magic-window')) {
                if (grabbedEl.parentNode) grabbedEl.parentNode.removeChild(grabbedEl);
            } else { this.createRandomElement(pinchPos); }
          },
          createRandomElement: function (pos) {
            const el = document.createElement(Math.random() < 0.5 ? 'a-box' : 'a-sphere');
            const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            if (el.tagName === 'A-BOX') el.setAttribute('depth', ELEMENT_SIZE);
            else el.setAttribute('radius', ELEMENT_SIZE/2);
            el.setAttribute('width', ELEMENT_SIZE); el.setAttribute('height', ELEMENT_SIZE);
            el.setAttribute('apply-magic-shader', `color: ${color}`);
            el.setAttribute('grabbable', ''); 
            el.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
            this.sceneEl.appendChild(el);
          }
        });

        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.sceneEl = document.querySelector('a-scene'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false; this.isRightPinching = false;
                this.isCreating = false; this.windowEl = null;

                const start = () => { this.checkStart(); };
                const end = () => { this.isLeftPinching = false; this.isRightPinching = false; clearTimeout(this.timeout); this.isCreating = false; };
                
                this.leftHand.addEventListener('pinchstarted', () => { this.isLeftPinching = true; start(); });
                this.leftHand.addEventListener('pinchended', end);
                this.rightHand.addEventListener('pinchstarted', () => { this.isRightPinching = true; start(); });
                this.rightHand.addEventListener('pinchended', end);
            },
            checkStart: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) this.toggleMagicWindow();
                    }, 3000);
                }
            },
            showStatusText: function(message) {
                const textEl = document.createElement('a-text');
                textEl.setAttribute('value', message); textEl.setAttribute('position', '0 2.0 -1.5'); 
                textEl.setAttribute('align', 'center'); textEl.setAttribute('look-at', '#mainCamera'); 
                this.sceneEl.appendChild(textEl);
                setTimeout(() => { if (textEl.parentNode) textEl.parentNode.removeChild(textEl); }, 2000);
            },
            toggleMagicWindow: function() {
                if (isMagicWindowVisible) {
                    if (this.windowEl) this.windowEl.parentNode.removeChild(this.windowEl);
                    isMagicWindowVisible = false;
                    this.showStatusText("Magic View Deleted");
                } else {
                    const camEl = document.getElementById('mainCamera');
                    const pos = new AFRAME.THREE.Vector3(0, 0, -0.5);
                    pos.applyMatrix4(camEl.object3D.matrixWorld);

                    this.windowEl = document.createElement('a-entity');
                    this.windowEl.setAttribute('geometry', `primitive: box; width: ${WINDOW_BOX_SIZE.w}; height: ${WINDOW_BOX_SIZE.h}; depth: ${WINDOW_BOX_SIZE.d};`); 
                    this.windowEl.setAttribute('position', pos); 
                    this.windowEl.setAttribute('grabbable', '');
                    this.windowEl.setAttribute('class', 'magic-window');
                    
                    this.windowEl.addEventListener('loaded', () => {
                        this.windowEl.object3D.lookAt(camEl.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
                    });
                    
                    this.windowEl.setAttribute('magic-window-sync', '');
                    this.windowEl.setAttribute('material', `color: ${COLOR_DEFAULT_ZONE}; wireframe: true; transparent: true; opacity: 0.3; side: double;`); 
                    this.sceneEl.appendChild(this.windowEl); 
                    isMagicWindowVisible = true;
                    this.showStatusText("Magic View Created");
                }
                magicObjects.forEach(cmp => cmp.setWindowActive(isMagicWindowVisible));
            }
        });
    </script>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <a-scene xr-mode-ui="XRMode: ar"> 
        <a-camera id="mainCamera" position="0 1.6 0"></a-camera>
        <a-box position="0 1.2 -0.2" rotation="0 45 0" width="0.1" height="0.1" depth="0.1" apply-magic-shader="color: #FF0000" grabbable></a-box>
        <a-sphere position="0 1.2 -2.0" radius="0.1" apply-magic-shader="color: #00FF00" grabbable></a-sphere>
        
        <a-entity id="leftHand" hand-tracking-controls="hand: left" double-pinch-creator-deleter magic-window-creator></a-entity>
        <a-entity id="rightHand" hand-tracking-controls="hand: right" hand-tracking-grab-controls="hand: right; hoverEnabled: true;"></a-entity>
    </a-scene>
</body>
</html>