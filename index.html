<!DOCTYPE html>
<html>
<head>
    <title>A-Frame AR Magic Window (Shader Fixed)</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition; // 传递视图空间坐标

        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);

            // 计算相对于相机的坐标 (View Space)
            // 在 Three.js 中，相机位于原点 (0,0,0) 看向 -Z 方向
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            vViewPosition = mvPosition.xyz;

            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec3 uBaseColor;
        
        // Magic Window 参数 (必须与 JS 中的设置匹配)
        // Window 固定在相机前方 Z = -0.5 的位置
        const float WINDOW_Z = -0.5;
        const float WINDOW_WIDTH = 0.4;
        const float WINDOW_HEIGHT = 0.3;
        
        // 收缩因子，避免边缘闪烁
        const float SHRINK_FACTOR = 0.9; 

        // 透明度定义
        const float OPACITY_TRANSPARENT = 0.2;
        const float OPACITY_OPAQUE = 1.0;

        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        void main() {
            // 简单光照
            vec3 lightDir = normalize(vec3(0.5, 0.8, 1.0));
            float diff = max(dot(vNormal, lightDir), 0.0);
            vec3 finalColor = uBaseColor * (0.5 + 0.5 * diff);

            float alpha = OPACITY_OPAQUE;

            // --- 核心逻辑 ---
            
            // 1. 深度检查：物体必须在 Window 后面 (Z 更小/更负) 才能通过 Window 看到
            // 如果物体在 Window 前面 (比如 Z = -0.2)，它遮挡了 Window，不应变透明
            if (vViewPosition.z < WINDOW_Z) {
                
                // 2. 投影计算 (相似三角形)
                // 计算当前像素点投影到 Z = -0.5 平面上的坐标
                float projectionFactor = WINDOW_Z / vViewPosition.z;
                
                float projectedX = vViewPosition.x * projectionFactor;
                float projectedY = vViewPosition.y * projectionFactor;

                // 3. 范围检查
                float limitX = (WINDOW_WIDTH / 2.0) * SHRINK_FACTOR;
                float limitY = (WINDOW_HEIGHT / 2.0) * SHRINK_FACTOR;

                // 如果投影点在 Window 矩形内
                if (abs(projectedX) <= limitX && abs(projectedY) <= limitY) {
                    alpha = OPACITY_TRANSPARENT;
                }
            }

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        // 常量定义
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const MAGIC_WINDOW_Z_POS = -0.5; 
        const ELEMENT_SIZE = 0.1; 

        // === 组件：应用 Magic Shader ===
        AFRAME.registerComponent('apply-magic-shader', {
            schema: {
                color: {type: 'color', default: '#FFFFFF'}
            },
            
            init: function() {
                // 直接从 HTML 标签获取 Shader 内容，无需 fetch
                const vShader = document.getElementById('vertexShader').textContent;
                const fShader = document.getElementById('fragmentShader').textContent;
                
                this.material = new AFRAME.THREE.ShaderMaterial({
                    vertexShader: vShader,
                    fragmentShader: fShader,
                    uniforms: {
                        uBaseColor: { value: new AFRAME.THREE.Color(this.data.color) }
                    },
                    transparent: true,
                    side: AFRAME.THREE.DoubleSide
                });

                // 获取 mesh 并应用材质
                const mesh = this.el.getObject3D('mesh');
                if (mesh) {
                    mesh.material = this.material;
                } else {
                    // 如果 mesh 还没生成（例如 primitive刚创建），监听 model-loaded
                    this.el.addEventListener('model-loaded', () => {
                        const mesh = this.el.getObject3D('mesh');
                        if (mesh) mesh.material = this.material;
                    });
                    // 对于基础几何体 (a-box, a-plane)，通常 mesh 在 loaded 时也未必立即可用，
                    // 这里的 setTimeout 是个保险
                    setTimeout(() => {
                         const mesh = this.el.getObject3D('mesh');
                         if (mesh) mesh.material = this.material;
                    }, 100);
                }
            },

            update: function() {
                if (this.material) {
                    this.material.uniforms.uBaseColor.value.set(this.data.color);
                }
            }
        });

        // === 组件：双捏合创建/删除 ===
        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            const el = this.el; 
            this.lastPinchTime = 0;
            this.doubleClickThreshold = 300; 
            this.sceneEl = document.querySelector('a-scene');

            el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < this.doubleClickThreshold) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else {
                this.lastPinchTime = currentTime;
              }
            });
          },
          
          handleDoublePinch: function (pinchWorldPosition) {
            const rightGrabControls = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightGrabControls ? rightGrabControls.grabbedEl : null;
            
            if (grabbedEl && grabbedEl.hasAttribute('grabbable')) {
              if (grabbedEl.parentNode) {
                grabbedEl.parentNode.removeChild(grabbedEl);
              }
            } else {
              this.createRandomElement(pinchWorldPosition);
            }
          },
          
          createRandomElement: function (pinchWorldPosition) {
            const isBox = Math.random() < 0.5; 
            let newElement;
            const randomColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;

            if (isBox) {
                newElement = document.createElement('a-box');
                newElement.setAttribute('depth', ELEMENT_SIZE); 
            } else {
                newElement = document.createElement('a-plane');
                newElement.setAttribute('rotation', '0 0 0'); 
            }
            
            newElement.setAttribute('width', ELEMENT_SIZE);
            newElement.setAttribute('height', ELEMENT_SIZE);
            
            // 关键：应用 Shader 组件
            newElement.setAttribute('apply-magic-shader', `color: ${randomColor}`);
            
            newElement.setAttribute('shadow', '');
            newElement.setAttribute('grabbable', ''); 
            newElement.setAttribute('position', `${pinchWorldPosition.x} ${pinchWorldPosition.y} ${pinchWorldPosition.z}`);
            
            this.sceneEl.appendChild(newElement);
          }
        });

        // === 组件：Magic Window 线框创建 (仅视觉) ===
        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.cameraAnchorEl = document.getElementById('cameraAnchor'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false;
                this.isRightPinching = false;
                this.creationThreshold = 3000; 
                this.isCreating = false;

                this.leftHand.addEventListener('pinchstarted', (evt) => { this.isLeftPinching = true; this.checkStartCreation(); });
                this.leftHand.addEventListener('pinchended', () => { this.isLeftPinching = false; this.checkEndCreation(); });
                this.rightHand.addEventListener('pinchstarted', () => { this.isRightPinching = true; this.checkStartCreation(); });
                this.rightHand.addEventListener('pinchended', () => { this.isRightPinching = false; this.checkEndCreation(); });
            },

            checkStartCreation: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) {
                            this.createMagicWindow();
                            this.isCreating = false;
                        }
                    }, this.creationThreshold);
                }
            },

            checkEndCreation: function() {
                if (!this.isLeftPinching || !this.isRightPinching) {
                    clearTimeout(this.timeout);
                    this.isCreating = false;
                }
            },

            createMagicWindow: function() {
                // 清除旧的 (如果只想保留一个)
                this.cameraAnchorEl.innerHTML = '';

                const newWindow = document.createElement('a-entity');
                newWindow.setAttribute('magic-window', ''); 
                
                // 这里的尺寸必须和 Shader 中的 WINDOW_WIDTH/HEIGHT 对应
                newWindow.setAttribute('geometry', 'primitive: plane; width: 0.4; height: 0.3;'); 
                newWindow.setAttribute('position', `0 0 ${MAGIC_WINDOW_Z_POS}`); 
                newWindow.setAttribute('material', `color: ${COLOR_DEFAULT_ZONE}; wireframe: true; transparent: true; opacity: 1.0;`); 
                
                this.cameraAnchorEl.appendChild(newWindow); 
                console.log('Magic Window wireframe created!');
            }
        });

    </script>
    
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    
    <a-scene xr-mode-ui="XRMode: ar"> 
        
        <a-camera id="mainCamera">
            <a-entity id="cameraAnchor"></a-entity>
        </a-camera>
        
        <a-box 
            position="0 1.0 -0.6" 
            rotation="0 45 0" 
            width="0.1" 
            height="0.1" 
            depth="0.1" 
            apply-magic-shader="color: #FF0000"
            shadow
            grabbable> 
        </a-box>

        <a-entity 
            id="leftHand" 
            hand-tracking-controls="hand: left"
            double-pinch-creator-deleter
            magic-window-creator>
        </a-entity>

        <a-entity 
            id="rightHand" 
            hand-tracking-controls="hand: right"
            hand-tracking-grab-controls="hand: right; hoverEnabled: true;">
        </a-entity>
        
        <a-entity light="type: point; intensity: 1.5; decay: 2; color: #FFFFFF;" position="0 1 0"></a-entity>
        <a-entity light="type: ambient; intensity: 0.5;"></a-entity>

    </a-scene>

</body>
</html>