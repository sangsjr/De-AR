<!DOCTYPE html>
<html>
<head>
    <title>A-Frame AR Magic Window - Clean Silhouette</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script>
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const ELEMENT_SIZE = 0.1; 
        const WINDOW_BOX_SIZE = { w: 0.4, h: 0.3, d: 0.4 }; 

        let isMagicWindowVisible = false;
        let magicObjects = [];

        AFRAME.registerComponent('apply-magic-shader', {
            schema: { color: {type: 'color', default: '#FFFFFF'} },
            init: function() {
                magicObjects.push(this);
                const applyMat = () => {
                    const mesh = this.el.getObject3D('mesh');
                    if (!mesh) return;
                    mesh.material = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(this.data.color),
                        transparent: true,
                        opacity: 1.0,
                        stencilWrite: true,
                        stencilRef: 1,
                        stencilFunc: THREE.NotEqualStencilFunc, 
                        stencilZPass: THREE.KeepStencilOp
                    });
                };
                if (this.el.getObject3D('mesh')) applyMat();
                else this.el.addEventListener('model-loaded', applyMat);
            },
            remove: function() {
                const index = magicObjects.indexOf(this);
                if (index > -1) magicObjects.splice(index, 1);
            },
            setWindowActive: function(isActive) {
                const mesh = this.el.getObject3D('mesh');
                if (mesh) {
                    mesh.material.stencilFunc = isActive ? THREE.NotEqualStencilFunc : THREE.AlwaysStencilFunc;
                }
            }
        });

        AFRAME.registerComponent('magic-window-logic', {
            init: function() {
                const geometry = new THREE.BoxGeometry(WINDOW_BOX_SIZE.w, WINDOW_BOX_SIZE.h, WINDOW_BOX_SIZE.d);
                
                // --- A. 遮罩层 (Mask) ---
                const maskMat = new THREE.MeshBasicMaterial({
                    colorWrite: false,
                    depthWrite: false,
                    stencilWrite: true,
                    stencilRef: 1,
                    stencilFunc: THREE.AlwaysStencilFunc,
                    stencilZPass: THREE.ReplaceStencilOp
                });
                const maskMesh = new THREE.Mesh(geometry, maskMat);
                maskMesh.renderOrder = 0;

                // --- B. 2D 轮廓层 (Silhouette) ---
                // 修改点：让轮廓线也写入 Stencil 1
                const outlineMat = new THREE.ShaderMaterial({
                    uniforms: {
                        thickness: { value: 0.005 },
                        color: { value: new THREE.Color(COLOR_DEFAULT_ZONE) }
                    },
                    vertexShader: `
                        uniform float thickness;
                        void main() {
                            vec3 pos = position + normal * thickness;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        void main() { gl_FragColor = vec4(color, 1.0); }
                    `,
                    side: THREE.BackSide,
                    stencilWrite: true,
                    stencilRef: 1,
                    stencilFunc: THREE.NotEqualStencilFunc,
                    stencilZPass: THREE.ReplaceStencilOp // 修改点：轮廓线也会把 Stencil 设为 1
                });
                const outlineMesh = new THREE.Mesh(geometry, outlineMat);
                outlineMesh.renderOrder = 1;

                // --- C. 3D 线框层 (Wireframe) ---
                const edges = new THREE.EdgesGeometry(geometry);
                const wireframeLine = new THREE.LineSegments(
                    edges, 
                    new THREE.LineBasicMaterial({ 
                        color: COLOR_DEFAULT_ZONE,
                        stencilWrite: true,
                        stencilRef: 1,
                        stencilFunc: THREE.AlwaysStencilFunc,
                        stencilZPass: THREE.ReplaceStencilOp // 移动时的线框也参与挖洞
                    })
                );
                wireframeLine.visible = false; 

                this.el.setObject3D('mask', maskMesh);
                this.el.setObject3D('outline', outlineMesh);
                this.el.setObject3D('wireframe', wireframeLine);

                this.lastPos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(this.lastPos);
                this.isMoving = false;
                this.stopTimeout = null;

                this.el.addEventListener('grabstart', () => this.setMovingMode(true));
                this.el.addEventListener('grabend', () => this.setMovingMode(false));
            },

            setMovingMode: function(moving) {
                const outline = this.el.getObject3D('outline');
                const wireframe = this.el.getObject3D('wireframe');
                if (outline && wireframe) {
                    outline.visible = !moving;
                    wireframe.visible = moving;
                }
            },

            tick: function() {
                const currentPos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(currentPos);
                if (this.lastPos.distanceTo(currentPos) > 0.002) {
                    if (!this.isMoving) {
                        this.isMoving = true;
                        this.setMovingMode(true);
                    }
                    clearTimeout(this.stopTimeout);
                    this.stopTimeout = setTimeout(() => {
                        this.isMoving = false;
                        this.setMovingMode(false);
                    }, 150); 
                }
                this.lastPos.copy(currentPos);
            }
        });

        // 交互控制部分保持不变
        AFRAME.registerComponent('double-pinch-creator-deleter', {
          init: function () {
            this.lastPinchTime = 0;
            this.sceneEl = document.querySelector('a-scene');
            this.el.addEventListener('pinchstarted', (evt) => {
              const currentTime = Date.now();
              if (currentTime - this.lastPinchTime < 300) {
                this.handleDoublePinch(evt.detail.position);
                this.lastPinchTime = 0;
              } else { this.lastPinchTime = currentTime; }
            });
          },
          handleDoublePinch: function (pinchPos) {
            const rightHand = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
            const grabbedEl = rightHand ? rightHand.grabbedEl : null;
            if (grabbedEl && grabbedEl.hasAttribute('grabbable') && !grabbedEl.classList.contains('magic-window')) {
                if (grabbedEl.parentNode) grabbedEl.parentNode.removeChild(grabbedEl);
            } else { this.createRandomElement(pinchPos); }
          },
          createRandomElement: function (pos) {
            const el = document.createElement(Math.random() < 0.5 ? 'a-box' : 'a-sphere');
            const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
            if (el.tagName === 'A-BOX') el.setAttribute('depth', ELEMENT_SIZE);
            else el.setAttribute('radius', ELEMENT_SIZE/2);
            el.setAttribute('width', ELEMENT_SIZE); el.setAttribute('height', ELEMENT_SIZE);
            el.setAttribute('apply-magic-shader', `color: ${color}`);
            el.setAttribute('grabbable', ''); 
            el.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
            this.sceneEl.appendChild(el);
          }
        });

        AFRAME.registerComponent('magic-window-creator', {
            init: function () {
                this.sceneEl = document.querySelector('a-scene'); 
                this.leftHand = this.el;
                this.rightHand = document.getElementById('rightHand');
                this.isLeftPinching = false; this.isRightPinching = false;
                this.isCreating = false; this.windowEl = null;

                const start = () => { this.checkStart(); };
                const end = () => { this.isLeftPinching = false; this.isRightPinching = false; clearTimeout(this.timeout); this.isCreating = false; };
                
                this.leftHand.addEventListener('pinchstarted', () => { this.isLeftPinching = true; start(); });
                this.leftHand.addEventListener('pinchended', end);
                this.rightHand.addEventListener('pinchstarted', () => { this.isRightPinching = true; start(); });
                this.rightHand.addEventListener('pinchended', end);
            },
            checkStart: function() {
                if (this.isLeftPinching && this.isRightPinching && !this.isCreating) {
                    this.isCreating = true;
                    this.timeout = setTimeout(() => {
                        if (this.isLeftPinching && this.isRightPinching) this.toggleMagicWindow();
                    }, 3000);
                }
            },
            showStatusText: function(message) {
                const textEl = document.createElement('a-text');
                textEl.setAttribute('value', message); textEl.setAttribute('position', '0 2.0 -1.5'); 
                textEl.setAttribute('align', 'center'); 
                this.sceneEl.appendChild(textEl);
                setTimeout(() => { if (textEl.parentNode) textEl.parentNode.removeChild(textEl); }, 2000);
            },
            toggleMagicWindow: function() {
                if (isMagicWindowVisible) {
                    if (this.windowEl) this.windowEl.parentNode.removeChild(this.windowEl);
                    isMagicWindowVisible = false;
                    this.showStatusText("Magic View Deleted");
                } else {
                    const camEl = document.getElementById('mainCamera');
                    const pos = new AFRAME.THREE.Vector3(0, 0, -0.5);
                    pos.applyMatrix4(camEl.object3D.matrixWorld);

                    this.windowEl = document.createElement('a-entity');
                    this.windowEl.setAttribute('position', pos); 
                    this.windowEl.setAttribute('grabbable', '');
                    this.windowEl.setAttribute('class', 'magic-window');
                    this.windowEl.setAttribute('magic-window-logic', '');
                    this.windowEl.addEventListener('loaded', () => {
                        this.windowEl.object3D.lookAt(camEl.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
                    });
                    this.sceneEl.appendChild(this.windowEl); 
                    isMagicWindowVisible = true;
                    this.showStatusText("Magic View Created");
                }
                magicObjects.forEach(cmp => cmp.setWindowActive(isMagicWindowVisible));
            }
        });
    </script>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <a-scene xr-mode-ui="XRMode: ar" renderer="stencil: true; colorManagement: true;"> 
        <a-camera id="mainCamera" position="0 1.6 0"></a-camera>
        <a-box position="0 1.2 -0.2" rotation="0 45 0" width="0.1" height="0.1" depth="0.1" apply-magic-shader="color: #FF0000" grabbable></a-box>
        <a-sphere position="0 1.2 -2.0" radius="0.1" apply-magic-shader="color: #00FF00" grabbable></a-sphere>
        <a-entity id="leftHand" hand-tracking-controls="hand: left" double-pinch-creator-deleter magic-window-creator></a-entity>
        <a-entity id="rightHand" hand-tracking-controls="hand: right" hand-tracking-grab-controls="hand: right; hoverEnabled: true;"></a-entity>
    </a-scene>
</body>
</html>