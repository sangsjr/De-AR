<!DOCTYPE html>
<html>
<head>
    <title>3D Cone and Cube</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script>
        const COLOR_DEFAULT_ZONE = '#0000FF'; 
        const ELEMENT_SIZE = 0.1; 
        const WINDOW_BOX_SIZE = { w: 0.4, h: 0.3, d: 0.4 }; 

        let magicObjects = [];

        // 1. Stencil 方案组件
        AFRAME.registerComponent('apply-magic-shader', {
            schema: { color: {type: 'color', default: '#FFFFFF'} },
            init: function() {
                magicObjects.push(this);
                const applyMat = () => {
                    const mesh = this.el.getObject3D('mesh');
                    if (!mesh) return;
                    mesh.material = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(this.data.color),
                        transparent: true,
                        opacity: 1.0,
                        stencilWrite: true,
                        stencilRef: 1,
                        stencilFunc: THREE.NotEqualStencilFunc,
                        stencilZPass: THREE.KeepStencilOp
                    });
                };
                if (this.el.getObject3D('mesh')) applyMat();
                else this.el.addEventListener('model-loaded', applyMat);
            },
            remove: function() {
                const index = magicObjects.indexOf(this);
                if (index > -1) magicObjects.splice(index, 1);
            },
            updateStencil: function(isActive) {
                const mesh = this.el.getObject3D('mesh');
                if (mesh) {
                    mesh.material.stencilFunc = isActive ? THREE.NotEqualStencilFunc : THREE.AlwaysStencilFunc;
                }
            }
        });

        // 2. 魔法窗口逻辑
        AFRAME.registerComponent('magic-window-logic', {
            schema: { type: { type: 'string', default: 'box' } },
            init: function() {
                let geometry;
                if (this.data.type === 'cone') {
                    geometry = new THREE.ConeGeometry(0.2, 0.4, 32);
                } else {
                    geometry = new THREE.BoxGeometry(WINDOW_BOX_SIZE.w, WINDOW_BOX_SIZE.h, WINDOW_BOX_SIZE.d);
                }
                const maskMat = new THREE.MeshBasicMaterial({
                    colorWrite: false, depthWrite: false, stencilWrite: true,
                    stencilRef: 1, stencilFunc: THREE.AlwaysStencilFunc, stencilZPass: THREE.ReplaceStencilOp
                });
                const maskMesh = new THREE.Mesh(geometry, maskMat);
                maskMesh.renderOrder = 0;

                const outlineMat = new THREE.ShaderMaterial({
                    uniforms: { thickness: { value: 0.005 }, color: { value: new THREE.Color(COLOR_DEFAULT_ZONE) } },
                    vertexShader: `uniform float thickness; void main() { vec3 pos = position + normal * thickness; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }`,
                    fragmentShader: `uniform vec3 color; void main() { gl_FragColor = vec4(color, 1.0); }`,
                    side: THREE.BackSide, stencilWrite: true, stencilRef: 1, stencilFunc: THREE.NotEqualStencilFunc, stencilZPass: THREE.ReplaceStencilOp
                });
                const outlineMesh = new THREE.Mesh(geometry, outlineMat);
                outlineMesh.renderOrder = 1;

                this.el.setObject3D('mask', maskMesh);
                this.el.setObject3D('outline', outlineMesh);
            }
        });

        // 3. 交互管理器
        AFRAME.registerComponent('magic-interaction-manager', {
            init: function () {
                this.sceneEl = document.querySelector('a-scene');
                this.timers = { left: null, right: null };
                this.windows = { left: null, right: null };

                const setupHand = (handName) => {
                    const handEl = document.getElementById(handName + 'Hand');
                    handEl.addEventListener('pinchstarted', (evt) => {
                        // 严格检查：如果事件不是来自预设的那只手，直接忽略
                        if (evt.target !== handEl) return;

                        if (handName === 'right') {
                            const grabControls = handEl.components['hand-tracking-grab-controls'];
                            if (grabControls && grabControls.grabbedEl) return;
                        }

                        this.timers[handName] = setTimeout(() => {
                            this.toggleWindow(handName, handEl, evt.detail.position);
                        }, 3000);
                    });
                    handEl.addEventListener('pinchended', () => {
                        clearTimeout(this.timers[handName]);
                    });
                };
                setupHand('left');
                setupHand('right');
            },
            toggleWindow: function(handName, handEl, pos) {
                if (this.windows[handName]) {
                    this.sceneEl.removeChild(this.windows[handName]);
                    this.windows[handName] = null;
                } else {
                    const win = document.createElement('a-entity');
                    const type = (handName === 'left') ? 'cone' : 'box';
                    win.setAttribute('position', pos);
                    win.setAttribute('grabbable', '');
                    win.setAttribute('class', 'magic-window');
                    win.setAttribute('magic-window-logic', `type: ${type}`);
                    const camPos = document.getElementById('mainCamera').object3D.getWorldPosition(new THREE.Vector3());
                    win.addEventListener('loaded', () => { win.object3D.lookAt(camPos); });
                    this.sceneEl.appendChild(win);
                    this.windows[handName] = win;
                }
                const anyActive = this.windows.left || this.windows.right;
                magicObjects.forEach(obj => obj.updateStencil(!!anyActive));
            }
        });

        // 4. 【修复版】左手交互逻辑 - 增加多重校验防止误触发
        AFRAME.registerComponent('left-hand-complex-interaction', {
            init: function () {
                this.lastPinchTime = 0;
                
                this.el.addEventListener('pinchstarted', (evt) => {
                    // 保险 1: 必须是左手实体触发的事件，防止冒泡干扰
                    if (evt.target !== this.el) return;
                    
                    // 保险 2: 再次核对事件细节中的手部信息
                    // A-Frame 的手势事件会在 detail 中携带组件引用
                    const handData = this.el.getAttribute('hand-tracking-controls');
                    if (!handData || handData.hand !== 'left') return;

                    const now = Date.now();
                    const delta = now - this.lastPinchTime;

                    // 增加一个最小间隔 (50ms)，防止一次物理点击因为传感器抖动被识别成两次
                    if (delta < 300 && delta > 50) {
                        this.handleInteraction(evt.detail.position);
                        this.lastPinchTime = 0; // 成功后重置
                    } else {
                        this.lastPinchTime = now;
                    }
                });
            },
            handleInteraction: function (pinchPos) {
                const rightHandGrab = document.getElementById('rightHand').components['hand-tracking-grab-controls'];
                const grabbedEl = rightHandGrab ? rightHandGrab.grabbedEl : null;

                if (grabbedEl && !grabbedEl.classList.contains('magic-window')) {
                    if (grabbedEl.parentNode) grabbedEl.parentNode.removeChild(grabbedEl);
                } else {
                    this.createRandom(pinchPos);
                }
            },
            createRandom: function (pos) {
                const el = document.createElement(Math.random() < 0.5 ? 'a-box' : 'a-sphere');
                const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
                
                if (el.tagName === 'A-BOX') {
                    el.setAttribute('width', ELEMENT_SIZE); 
                    el.setAttribute('height', ELEMENT_SIZE); 
                    el.setAttribute('depth', ELEMENT_SIZE);
                } else {
                    el.setAttribute('radius', ELEMENT_SIZE / 2);
                }
                
                el.setAttribute('apply-magic-shader', `color: ${color}`);
                el.setAttribute('grabbable', ''); 
                el.setAttribute('position', pos);
                this.el.sceneEl.appendChild(el);
                
                const manager = this.el.sceneEl.components['magic-interaction-manager'];
                const anyWindow = (manager.windows.left || manager.windows.right);
                
                setTimeout(() => {
                    const comp = el.components['apply-magic-shader'];
                    if (comp) comp.updateStencil(!!anyWindow);
                }, 0);
            }
        });
    </script>
</head>
<body>
    <a-scene xr-mode-ui="XRMode: ar" renderer="stencil: true; colorManagement: true;" magic-interaction-manager> 
        <a-camera id="mainCamera" position="0 1.6 0"></a-camera>
        
        <a-sphere position="0 1.2 -0.5" radius="0.1" apply-magic-shader="color: #00FF00" grabbable></a-sphere>
        
        <a-entity id="leftHand" 
                  hand-tracking-controls="hand: left" 
                  left-hand-complex-interaction>
        </a-entity>

        <a-entity id="rightHand" 
                  hand-tracking-controls="hand: right" 
                  hand-tracking-grab-controls="hand: right">
        </a-entity>
    </a-scene>
</body>
</html>